"""
Copyright 2023 Sony Semiconductor Solutions Corp. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""
# automatically generated by the FlatBuffers compiler, do not modify

# namespace: SmartCamera

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class SemanticSegmentationData(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SemanticSegmentationData()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSemanticSegmentationData(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # SemanticSegmentationData
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SemanticSegmentationData
    def Height(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
        return 0

    # SemanticSegmentationData
    def Width(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
        return 0

    # SemanticSegmentationData
    def ClassIdMap(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint16Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 2))
        return 0

    # SemanticSegmentationData
    def ClassIdMapAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint16Flags, o)
        return 0

    # SemanticSegmentationData
    def ClassIdMapLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SemanticSegmentationData
    def ClassIdMapIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # SemanticSegmentationData
    def NumClassId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
        return 0

    # SemanticSegmentationData
    def ScoreMap(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # SemanticSegmentationData
    def ScoreMapAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # SemanticSegmentationData
    def ScoreMapLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SemanticSegmentationData
    def ScoreMapIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def SemanticSegmentationDataStart(builder): builder.StartObject(5)
def Start(builder):
    return SemanticSegmentationDataStart(builder)
def SemanticSegmentationDataAddHeight(builder, height): builder.PrependUint16Slot(0, height, 0)
def AddHeight(builder, height):
    return SemanticSegmentationDataAddHeight(builder, height)
def SemanticSegmentationDataAddWidth(builder, width): builder.PrependUint16Slot(1, width, 0)
def AddWidth(builder, width):
    return SemanticSegmentationDataAddWidth(builder, width)
def SemanticSegmentationDataAddClassIdMap(builder, classIdMap): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(classIdMap), 0)
def AddClassIdMap(builder, classIdMap):
    return SemanticSegmentationDataAddClassIdMap(builder, classIdMap)
def SemanticSegmentationDataStartClassIdMapVector(builder, numElems): return builder.StartVector(2, numElems, 2)
def StartClassIdMapVector(builder, numElems):
    return SemanticSegmentationDataStartClassIdMapVector(builder, numElems)
def SemanticSegmentationDataAddNumClassId(builder, numClassId): builder.PrependUint16Slot(3, numClassId, 0)
def AddNumClassId(builder, numClassId):
    return SemanticSegmentationDataAddNumClassId(builder, numClassId)
def SemanticSegmentationDataAddScoreMap(builder, scoreMap): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(scoreMap), 0)
def AddScoreMap(builder, scoreMap):
    return SemanticSegmentationDataAddScoreMap(builder, scoreMap)
def SemanticSegmentationDataStartScoreMapVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartScoreMapVector(builder, numElems):
    return SemanticSegmentationDataStartScoreMapVector(builder, numElems)
def SemanticSegmentationDataEnd(builder): return builder.EndObject()
def End(builder):
    return SemanticSegmentationDataEnd(builder)